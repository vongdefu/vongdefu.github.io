# 线程产生的背景

> 1. 冯诺依曼体系【不同缓存之间的访问的速度差异】
> 2. 线程的优化手段及其产生的问题
> 3. 并发安全级别及同步手段
> 4. Java 内存模型、Happens-Before 原则、As-If 原则
> 5. 指令优化手段、线程同步优化、编译器优化等

## 前置知识点

### 背景

1. 最初的计算机只能接受简单的少量指令，当用户在思考或输入时，计算机就在等待，这就使得计算机的工作效率极其低下；
2. 后来出现支持批处理系统的计算机，人们可以把计算机指令写成一个清单，然后统一交给计算机处理，例如纸带式的计算机，虽然效率有所提升，但是有些程序的运行中，依然有 CPU 等核心资源处于闲置状态，并且只能处理单个应用程序，也就是说这种计算机的性能依旧没有被压榨到极致；
3. 可以说，“计算机科学”的发展史就是围绕着“如何极限压榨计算机性能”——这一问题进行的。
4. 人们针对这一核心问题，提出了一整套的解决方案。
5. 这里面包含的内容极多，有计算机硬件、操作系统、数据结构与算法、编译器优化等等，很多学科的内容，比如，
   1. **硬件体系**中添加了多级缓存以求解决“如何缩短「读取指令」和「运算指令」的速度差异”的问题；
   2. **操作系统层面**使用「分时复用」+「任务调度」等技术来解决“ CPU 执行时间如何划分”、“不同任务如何切换”、“多个指令如何进行划分、组合与合并”等问题；
   3. **数据结构与算法**层面解决同一任务不同算法、不同存储空间的最优解问题；
6. 并且这些内容也都是糅合在一起使用的；

### 名词解释

- 应用程序、进程、线程

  应用程序：用某种编程语言(java、python 等)编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，本质上是一段静态代码。

  进程：就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。

  比如，在 Windows 平台上，idea 的运行，idea 就是应用程序，我们打开任务管理器，可以在 idea 下面看到有多个进程：

  ![1741347571590](./ch01-background/image/1741347571590.png)

  也就是说，人们把应用程序从占用资源的角度，划分成多个不同的进程，当某一个进程运行时，它会占用 CPU、内存等资源，但是当它挂起时，CPU 等计算资源就可能会处于空闲状态，这就说明划分粒度还是不够小，于是人们又提出线程的概念。

  狭义：进程是正在运行的程序的实例。
  广义：进程是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动。

  进程是操作系统动态执行的基本单元，在传统的操作系统中，进程即是基本的分配单元，也是基本的执行单元。

  线程是操作系统能够进行运算调试的最小单位。它被包含在进程中，是进程中的实际动作单位。一个线程指的是进程中的一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程执行不同的任务。

- 同步（Synchronous）和异步（Asynchronous）

  在 Java 领域中，同步和异步通常用来描述方法的调用。如果说调用者必须要等待方法的返回才能进行下一步操作，那么就说这次调用是同步的；如果说调用者不必等待方法的返回结果，只是执行了一次方法的调用，就可以直接执行方法下面的操作，那么就说这个方法是异步调用的。

  比如说，现在有这样一个业务场景，在代码中我们需要调用一个外围系统的接口取回一些数据，然后把数据进行处理一下，再返回给前端。如果在调用外围系统时，需要阻塞住，非要等到外围系统返回结果才往下执行其他内容，那么这种场景就是同步调用的场景；如果调用外围系统时，只是发起外围系统的接口调用过程，并没有非要等着外围系统返回结果才往下进行，那么这种场景就是异步的。

  > 在日常交流中，我们说“同步一下某一个方案”，也会用到同步这个说法，这里的同步表示共享、使大家统一意见。

- 同步访问和互斥访问

  同步，意味着线程之间要密切合作，按照一定的顺序来执行任务。比如说，线程 A 先执行，线程 B 再执行。

  互斥，意味着线程之间要抢占资源，同一时间只能有一个线程访问共享资源。比如说，线程 A 在访问共享资源时，线程 B 不能访问。

  同步关注的是线程之间的协作，互斥关注的是线程之间的竞争。

- 并发和并行

  并行是多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行。

  并发是单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行，用于解决 IO 密集型任务的瓶颈。

- **上下文**

- **守护线程和用户线程**

- 线程调度

- 临界区

- 死锁

  死锁就是两个或两个以上的线程因抢占锁而造成的互相等待的现象。

  - 死锁产生必要条件：

    - **互斥**：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。
    - **持有并等待**：一个线程已经持有一个资源，并且在等待获取其他线程持有的资源。
    - **不可抢占**：资源不能被强制从线程中夺走，必须等线程自己释放。
    - **循环等待**：存在一种线程等待链，线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，直到线程 N 又等待线程 A 持有的资源。
    - 四个条件的关系：四个条件缺一不可，必须同时满足才可能产生死锁。

  - 如何避免死锁： 要想避免死锁，只需要破坏其中一个条件即可。

  - 如何排查死锁？

- 线程安全、线程安全三要素、线程安全程度

  所谓线程安全，就是多线程并发场景下，针对共享数据的访问问题，如果多线程访问共享数据时，共享数据的结果值与多线程访问完共享数据后的期望值一致，则表明共享数据是线程安全的。

  在多线程场景下，共享变量的实际运行后的值总能与期望值保持一致，这样的共享变量就可以被称为是线程安全的。

  JMM 是 Java 定义的一套的多线程通过共享内存的方式进行数据通信以及指令同步的实现规范，通过这个规范，让 Java 并发编程成为现实。

  并发编程三要素与 JMM 的关系： 并发编程三要素是任何支持并发编程的高级语言都必须要考虑和实现的基本要素。JMM——俗称 Java 内存模型，严格上讲，JMM 是指 Java 内存模型和它配套的一系列基础设施【下面统称为 JMM 机制】，通过这套机制，Java 语言成功实现了并发编程的设计目标。也可以说，并发编程三要素是理论基础，JMM 机制是 Java 语言的具体实现。下面是并发编程三要素的相关概念以及 JMM 机制对并发编程三要素的支持手段：

  - **原子性（Atomicity）**： 要想实现线程安全，就必须要满足：一个操作（或多个操作的组合）要么全部执行且不可中断，要么完全不执行，不能有中间状态。
    - JMM 不直接保证大多数操作的原子性（如 i++是非原子操作，涉及读、改、写三步）。但 JMM 通过以下机制间接实现原子性：
      - synchronized 关键字：通过锁机制确保临界区代码的原子性。
      - 原子类（AtomicInteger 等）：基于 CAS（Compare-And-Swap）指令实现无锁原子操作。
      - volatile 变量：仅保证单次读/写操作的原子性（如 volatile long 的读写是原子的）。
  - **有序性（Ordering）**： 要想实现线程安全， 就必须要满足：程序执行的顺序符合代码的语义逻辑（避免指令重排序导致的意外结果）。
    - JMM 通过以下机制限制指令重排序：
      - volatile 关键字：禁止对 volatile 变量的读/写操作与其前后的其他指令重排序。
      - synchronized/锁：临界区内的代码不会被重排序到锁外。
      - Happens-Before 规则：JMM 定义了一系列 Happens-Before 规则（如程序顺序规则、锁规则、volatile 规则等），确保编译器/处理器优化不会破坏多线程的正确性。
  - **可见性（Visibility）**： 要想实现线程安全，就必须要满足： 一个线程对共享变量的修改，其他线程能立即看到最新值。

    - JMM 通过以下规则保证可见性：
      - volatile 变量：写入 volatile 变量时，会立即刷新到主内存；读取时直接从主内存获取。
      - 锁机制（synchronized 或 Lock）：线程释放锁前会将修改的变量刷新到主内存；获取锁时会清空工作内存，重新从主内存加载变量。
      - final 关键字：正确初始化的 final 变量在构造结束后对其他线程可见。
      - Happens-Before 规则：若操作 A Happens-Before 操作 B，则 A 的修改对 B 可见。

  - **Happens-Before 和 As-If-Serial**
    - Happens-Before（先行发生原则），是 Java 并发编程模型中定义的两个操作之间发生的顺序的一套编程规范。【周志明《深入理解 Java 虚拟机》ch12.3.6 先行发生原则】，主要包括 8 个：
      - 程序次序规则（Program Order Rule）：单线程内，代码按顺序执行；比如 `a = 1; b = 2;`，a 先于 b 执行。
      - 管程锁定规则（Monitor Lock Rule）：`unlock() Happens-Before lock()`；比如 synchronized 释放锁后，获取锁的线程能够看到最新的数据。
      - volatile 变量规则（Volatile Variable Rule）：写 volatile 变量 Happens-Before 读 volatile。
      - 线程启动规则（Thread Start Rule）：Thread 对象的 start()方法先行发生于此线程的每一个动作。
      - 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。线程的所有操作 Happens-Before `Thread.join()`；例如 `t.join();` 之后，主线程一定能看到 t 的修改。
      - 线程中断规则（Thread Interruption Rule）： 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted()方法检测到是否有中断发生；
      - 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始；
      - 传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论；
    - As-If-Serial 规则允许 CPU 和编译器优化代码顺序，但不会改变单线程的执行结果。它只适用于单线程，多线程环境仍然可能发生指令重排，需要 volatile 和 synchronized 等机制来保证有序性。

  线程安全程度：线程安全与否，并不是一个非黑即白的二元概念。

  通常情况下，约束越多，效率越低；约束越少，效率越高；这个概念可以看作是执行性能与限制手段之间的平衡，按照不同的限制手段带来的不同的执行性能进行分级，于是就有了线程安全程度这个概念。【周志明《深入理解 Java 虚拟机》ch13.2.1 java 语言中的线程安全】

  - **不可变**： 只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。
    - 多线程环境下，应当尽量使对象成为不可变，来满足线程安全。
    - java 中不可变的类型:
      - final 关键字修饰的基本数据类型
      - String
      - 枚举类型
      - Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。
      - 集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合
  - **绝对线程安全**： 不管运行时环境如何，调用者都不需要任何额外的同步措施。
  - **相对线程安全**： 相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。
    - 在 Java 语言中，大部分声称线程安全的类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection()方法包装的集合等。
  - **线程兼容**： 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。
    - Java 类库 API 中大部分的类都是线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。
  - **线程对立**： 线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于 Java 语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。
    - Java 中一个线程对立的例子是 Thread 类的 suspend()和 resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如 suspend()中断的线程就是即将要执行 resume()的那个线程，那就肯定要产生死锁了。也正是这个原因，suspend()和 resume()方法都已经被声明废弃了。常见的线程对立的操作还有 System.setIn()、Sytem.setOut()和 System.runFinalizersOnExit()等。

## Java 中线程与操作系统的映射

![摘自-周志明《深入理解Java虚拟机》](./ch01-background/image/1741348217123.png)

这就说明 Java 中的线程与底层操作系统属于一一映射的关系，也就是说 Java 中线程的执行是由 JVM 提交给操作系统执行的，既然提交给底层操作系统，那么这些线程的调度也是由底层操作系统控制的，所以说 Java 的线程的执行具有一定的随机性。

这也是为什么说 Java 中线程的优先权的设置的执行结果并不一定准确的原因，也是为什么说 wait 之后可能在交出执行权之后又立马被调度的原因。

## Java 线程的内存模型-JMM

![1741349007944](./ch01-background/image/1741349007944.png)

### 线程的调度

在计算机操作系统中，是通过分配时间片来执行指令的，因此涉及到线程的调度。现代操作系统的调度方式有两种，一种是轮询调度方式，一种是抢占式调度方式。轮询调度方式就是把对排队中的线程分别分配一个时间片来执行，而抢占式调度方式，则是根据线程的优先级来确定的，优先级高的就优先分配时间片。java 中的线程调度是委托操作系统进行的，但 java 中可以针对线程的执行顺序设置优先级。

### 线程优先级

在 Thread 类中有一个属性专门标识了线程的优先级，默认是 5，最小值是 1，最大值是 10，数值越大，说明优先级越高。但需要注意的一点是，优先级高的线程不一定就比优先级低的线程执行的快，因为操作系统调度线程完全是随机的。具体调用哪个线程进行执行，只有天知道。

![1742544574651](./ch01-background/image/1742544574651.png)

### 线程的生命周期

![jdk1.8源码](./ch01-background/image/1742544667548.png)

Thread 类中有一个内部枚举类 State， public static enum Thread.State extends Enum<Thread.State> 。标识了线程从新建到消亡的各个阶段的状态。State 的枚举值有：

- `NEW` ： 创建成功但还没有执行 Start()方法的线程都处于 NEW 状态；
- `RUNNABLE`
  - 操作系统中对此状态细分成两种状态，就绪状态和运行状态，这两种状态统称为 RUNNABLE 状态；
  - 在执行了 start() 方法后，线程进入就绪状态，就是上下文运行环境已经准备完毕，如果获得操作系统的运行时间片，就进入运行状态；
  - 时间片执行完，线程又进入就绪状态，等待被分配下一个时间片；
- `BLOCKED` ： 阻塞状态 A thread that is blocked waiting for a monitor lock is in this state.
- `WAITINT` ： 等待状态
- `TIMED_WAITING` ： 限时等待状态
- `TERMINATED` ： 线程执行结束，结束有两种可能，一种是正常结束，一种是遇到异常

![摘自-周志明《深入理解Java虚拟机》](./ch01-background/image/1741338781290.png)

![摘自-周志明《深入理解Java虚拟机》](./ch01-background/image/1741338815734.png)

- [ ] 阻塞状态和等待状态以及限时等待状态的区别

## 单线程的创建方式

java 中**创建单线程**有三种方式：

::: tabs

@tab 1. 继承 Thread 类

```java
// 创建
class MyThread extends Thread{
    @Override
    public void run(){
      // do something
    }
}

// 使用
MyThread m = new MyThread();
m.start();

```

@tab 2. 实现 Runnable 接口

```java

// 实现runnable
// 创建一个任务对象
MyRunnable r = new MyRunnable();
// 创建一个线程并给他一个任务
Thread t = new Thread(r);
// 启动线程
t.start();

```

@tab 3. 实现 Callable 接口

```java
class Mycallable implements Callable<T> {
    @Override
    public <T> call() throws Exception {
      return T;
    }
}

// 使用
Callable<Integer> callable= new MyCallable();
FutureTask<Integer> future = new FutureTask<>(callable);
new Thread(future).start();
Integer j=task.get();
System.out.println("return"+j);

```

:::

- 三种方式的异同
  - 实现 Runnable 接口方式与继承 Thread 类的方式的区别
    - 通过创建任务，然后给线程分配任务的方式实现多线程，更适合多个线程同时执行任务的情况
    - 可以避免单继承所带来的局限性
    - 任务与线程是分离的，提高了程序的健壮性
    - 后期学习的线程池技术，接受 Runnable 类型的任务，不接受 Thread 类型的线程
  - 实现 Callable 接口方式，相当于又在实现 Runnable 接口方式上添加了返回值的过程

除此以外，还有线程池的两种方式：

- 一种是 juc 提供的原生线程池的方法，需要设置各种参数；
- 一种是 juc 提供的静态工厂创建线程池的方法；

## API

- `currentThread` 线程名称的设置与获取
- `start` 的执行顺序与线程的执行顺序不一致
- `currentThread` 方法用来获取当前执行线程的名称
- `isAlive` 用来判断线程是否还在存活状态，活动状态就是线程已经启动且运行没有结束。线程处于正在运行或准备开始运行的状态，就认为线程是『存活』的状态
- `sleep` 让当前线程睡眠，让出 CPU，使线程从执行状态变成限时阻塞状态。等待时间结束后，线程不一定会立即执行，线程状态会变成可执行状态。作用是在指定的毫秒数内让当前『正在执行的线程』暂停执行。
- `getId` 方法，作用是获取当前线程的唯一标识
- 停止线程
  - `stop` 方法强制结束线程。stop 方法已经被作废，如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个原因是对锁定的对象进行『解锁』，导致数据得不同同步的处理，出现数据不一致性的问题。
  - 也可以使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止。
- `interrupt` 让当前线程进入阻塞状态。调用 interrupt 方法不会真正的结束线程，在当前线程中打上一个停止的标记。Thread 类提供了 interrupted 方法测试当前线程是否中断，isInterrupted 方法测试线程是否已经中断。如果程中有 sleep 代码，不管是否进入到 sleep 的状态，如果调用了 interrupt 方法都会产生异常信息。
- 暂停线程使用 `suspend` ，重启暂停线程使用 resume 方法，suspend 如果独占公共的同步对象，使其它线程无法访问公共同步对象，suspend 会造成共享对象数据不同步
- `join` 多个线程进行合并，本质是：线程 a 需要在合并点进行等待，一直等到 b 线程执行完，或者等待超时时，才继续执行。
- `yeild` 此方法相当于让当前线程让出 cpu 执行权限，让 cpu 执行其他线程，但是此方法虽然会让当前线程暂停，但是不会行阻塞当前线程，只是让线程转入就绪状态，可能当前线程暂停了一下，又立即获得了 cpu 的执行权限，又开始执了。
- 线程的优先级
  - 在操作系统中，线程可以划分优先级，优先级较高的线程得到更多的 CPU 资源，也就 CPU 会优先执行优先级较高的线程对象中的任务。设置线程优先有助于帮助『线程调度器』确定在下一次选择哪个线程优先执行。
  - 设置线程的优先级使用 setPriority 方法，优级分为 1~10 个级别，如果设置优先级小于 1 或大于 10，JDK 抛出 IllegalArgumentException。JDK 默认设置 3 个优先级常量，MIN_PRIORITY=1(最小值)，NORM_PRIORITY=5(中间值，默认)，MAX_PRIORITY=10(最大值)。
  - 获取线程的优先级使用 getPriority 方法。
  - 线程的优先级具有继承性，比如线程 A 启动线程 B，线程 B 的优先级与线程 A 是一样的。
  - 高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部执行完。当线程优先级的等级差距很大时，谁先执行完和代码的调用顺序无关。
  - 线程的优先还有『随机性』，也就是说优先级高的线不一定每一次都先执行完成。
- `daemon` 线程分为两类，守护线程和用户线程。守护线程指在用户线程执行过程中，在后台提供某些通用服务的线程。GC 线程就是守护线程。守护线程是一种特殊的线程，特殊指的是当进程中不存在用户线程时，守护线程会自动销毁。典型的守护线程的例子就是垃圾回收线程，当进程中没有用户线程，垃圾回收线程就没有存在的必要了，会自动销毁。设置守护线程必须要在调用 start 方法之前设置，否则 JDK 会产生 IllegalThreadStateException
- `wait`

### 线程间的通信和线程间的协作

1. 什么是线程间的通信；
2. Java 中实现线程间通信的方式有哪些？
