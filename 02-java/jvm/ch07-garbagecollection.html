<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vongdefu.github.io/02-java/jvm/ch07-garbagecollection.html"><meta property="og:site_name" content="cs-tips"><meta property="og:title" content="7. 垃圾回收理论"><meta property="og:description" content="1. 研究方法 1. 明确需要回收的区域在运行期内存结构模型中的位置; 堆; 2. 明确何为垃圾（或垃圾有何特点）; 3. 明确如何定位垃圾（或如何标记垃圾）; 3. 明确如何回收垃圾（或垃圾回收算法）; 4. 明确垃圾回收的时机; 5. 垃圾回收需要考虑的问题; 6. GC类型; 2. 回收区域在运行期内存结构模型中的位置 栈管运行、堆管存储; 线程..."><meta property="og:type" content="article"><meta property="og:image" content="https://vongdefu.github.io/"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="7. 垃圾回收理论"><meta property="article:author" content="vongdefu"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"7. 垃圾回收理论","image":["https://vongdefu.github.io/"],"dateModified":null,"author":[{"@type":"Person","name":"vongdefu","url":"https://github.com/vongdefu"}]}</script><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>7. 垃圾回收理论 | cs-tips</title><meta name="description" content="1. 研究方法 1. 明确需要回收的区域在运行期内存结构模型中的位置; 堆; 2. 明确何为垃圾（或垃圾有何特点）; 3. 明确如何定位垃圾（或如何标记垃圾）; 3. 明确如何回收垃圾（或垃圾回收算法）; 4. 明确垃圾回收的时机; 5. 垃圾回收需要考虑的问题; 6. GC类型; 2. 回收区域在运行期内存结构模型中的位置 栈管运行、堆管存储; 线程...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-8909e15b.css" as="style"><link rel="stylesheet" href="/assets/style-8909e15b.css">
    <link rel="modulepreload" href="/assets/app-fb6938a2.js"><link rel="modulepreload" href="/assets/framework-16b96b76.js"><link rel="modulepreload" href="/assets/ch07-garbagecollection.html-e49a76f3.js"><link rel="modulepreload" href="/assets/ch07-garbagecollection.html-1560dcfb.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="cs-tips"><!----><span class="site-name hide-in-pad">cs-tips</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/01-csbase" class="nav-link" aria-label="要点提示"><span class="font-icon icon iconfont icon-ability" style=""></span>要点提示<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://github.com/vongdefu/vongdefu.github.io/issues" rel="noopener noreferrer" target="_blank" aria-label="问题反馈" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>问题反馈<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/vongdefu/vongdefu.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><!----><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">面渣</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="title">01-CS基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="title">02-Java编程语言</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">Java基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><a href="/02-java/juc/" class="title">JUC</a><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><!----><a href="/02-java/jvm/" class="title">JVM</a><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/02-java/jvm/ch01-overview.html" class="nav-link sidebar-link sidebar-page" aria-label="1. 概述"><!---->1. 概述<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch02-compileandbytecode.html" class="nav-link sidebar-link sidebar-page" aria-label="2. 前端编译阶段及字节码文件"><!---->2. 前端编译阶段及字节码文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch03-classload.html" class="nav-link sidebar-link sidebar-page" aria-label="3. 类加载"><!---->3. 类加载<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch04-threadmode.html" class="nav-link sidebar-link sidebar-page" aria-label="4. 线程模型"><!---->4. 线程模型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch05-runtime.html" class="nav-link sidebar-link sidebar-page" aria-label="5. 运行时内存结构"><!---->5. 运行时内存结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch06-engine.html" class="nav-link sidebar-link sidebar-page" aria-label="6. 执行引擎"><!---->6. 执行引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="7. 垃圾回收理论"><!---->7. 垃圾回收理论<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_1-研究方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 研究方法"><!---->1. 研究方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_2-回收区域在运行期内存结构模型中的位置" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 回收区域在运行期内存结构模型中的位置"><!---->2. 回收区域在运行期内存结构模型中的位置<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_3-垃圾对象定位" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 垃圾对象定位"><!---->3. 垃圾对象定位<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_4-垃圾回收算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 垃圾回收算法"><!---->4. 垃圾回收算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_4-1-垃圾对象特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1. 垃圾对象特点"><!---->4.1. 垃圾对象特点<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_5-垃圾回收的时机" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 垃圾回收的时机"><!---->5. 垃圾回收的时机<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_6-垃圾回收需要考虑的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 垃圾回收需要考虑的问题"><!---->6. 垃圾回收需要考虑的问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_7-gc类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. GC类型"><!---->7. GC类型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_7-0-1-minor-gc、major-gc、full-gc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.0.1. Minor GC、Major GC、Full GC"><!---->7.0.1. Minor GC、Major GC、Full GC<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_8-垃圾回收器分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8. 垃圾回收器分类"><!---->8. 垃圾回收器分类<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch08-hotspot.html" class="nav-link sidebar-link sidebar-page" aria-label="8. Hotspot"><!---->8. Hotspot<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch09-tools.html" class="nav-link sidebar-link sidebar-page" aria-label="9. 工具包"><!---->9. 工具包<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/02-java/jvm/ch10-promote.html" class="nav-link sidebar-link sidebar-page" aria-label="10. 调优"><!---->10. 调优<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-layout" style=""></span><span class="title">03-框架</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-api" style=""></span><span class="title">04-中间件</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-structure" style=""></span><span class="title">05-分布式</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-like" style=""></span><span class="title">06-软件质量管理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-editor" style=""></span><span class="title">07-工程设计</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->7. 垃圾回收理论</h1><!----><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_1-研究方法" class="router-link-active router-link-exact-active toc-link level3">1. 研究方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_2-回收区域在运行期内存结构模型中的位置" class="router-link-active router-link-exact-active toc-link level3">2. 回收区域在运行期内存结构模型中的位置</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_3-垃圾对象定位" class="router-link-active router-link-exact-active toc-link level3">3. 垃圾对象定位</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_4-垃圾回收算法" class="router-link-active router-link-exact-active toc-link level3">4. 垃圾回收算法</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_4-1-垃圾对象特点" class="router-link-active router-link-exact-active toc-link level4">4.1. 垃圾对象特点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_5-垃圾回收的时机" class="router-link-active router-link-exact-active toc-link level3">5. 垃圾回收的时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_6-垃圾回收需要考虑的问题" class="router-link-active router-link-exact-active toc-link level3">6. 垃圾回收需要考虑的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_7-gc类型" class="router-link-active router-link-exact-active toc-link level3">7. GC类型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_7-0-1-minor-gc、major-gc、full-gc" class="router-link-active router-link-exact-active toc-link level5">7.0.1. Minor GC、Major GC、Full GC</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/02-java/jvm/ch07-garbagecollection.html#_8-垃圾回收器分类" class="router-link-active router-link-exact-active toc-link level3">8. 垃圾回收器分类</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="_7-垃圾回收理论" tabindex="-1"><a class="header-anchor" href="#_7-垃圾回收理论" aria-hidden="true">#</a> 7. 垃圾回收理论</h1><h3 id="_1-研究方法" tabindex="-1"><a class="header-anchor" href="#_1-研究方法" aria-hidden="true">#</a> 1. 研究方法</h3><ul><li><ol><li>明确需要回收的区域在运行期内存结构模型中的位置</li></ol><ul><li>堆</li></ul></li><li><ol start="2"><li>明确何为垃圾（或垃圾有何特点）</li></ol></li><li><ol start="3"><li>明确如何定位垃圾（或如何标记垃圾）</li></ol></li><li><ol start="3"><li>明确如何回收垃圾（或垃圾回收算法）</li></ol></li><li><ol start="4"><li>明确垃圾回收的时机</li></ol></li><li><ol start="5"><li>垃圾回收需要考虑的问题</li></ol></li><li><ol start="6"><li>GC类型</li></ol></li></ul><h3 id="_2-回收区域在运行期内存结构模型中的位置" tabindex="-1"><a class="header-anchor" href="#_2-回收区域在运行期内存结构模型中的位置" aria-hidden="true">#</a> 2. 回收区域在运行期内存结构模型中的位置</h3><ul><li>栈管运行、堆管存储 <ul><li>线程私有区域：可以完全交由负责运行的线程来管理，线程运行结束，所占用的内存空间自然就应该被回收</li><li>线程共享区域： 生命周期与JVM的生命周期一致，需要额外的收集器进行收集 <ul><li>方法区 <ul><li>永久区/元空间 <ul><li>基本不收集，回收条件苛刻，判断一个类是否可以被回收，需同时满足 <ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ul></li></ul></li><li>Java堆 <ul><li>新生代 <ul><li>频繁收集</li></ul></li><li>老年代 <ul><li>较少收集</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="_3-垃圾对象定位" tabindex="-1"><a class="header-anchor" href="#_3-垃圾对象定位" aria-hidden="true">#</a> 3. 垃圾对象定位</h3><ul><li><p>引用计数法</p><ul><li>原理 <ul><li>给对象引用次数设置一个变量，每引用一次，就对这个变量+1，使用之后变量-1，变量为0即代表对象没有被引用，可以被回收，此对象属于垃圾对象</li></ul></li><li>缺点 <ul><li><ol><li>需要额外的空间来存储引用次数，增加了空间的开销</li></ol></li><li><ol start="2"><li>每次删减引用后，都需要操作这块空间，增加了时间的开销</li></ol></li><li><ol start="3"><li>无法处理循环引用的问题</li></ol></li></ul></li><li>优点 <ul><li>实现简单、回收效率高</li></ul></li></ul></li><li><p>可达性分析（Hotspot采用的方法）</p><ul><li>基本原理 <ul><li>在某一时刻的快照里，以GCRoot作为起始点，向下收集，收集的路径称为引用链，引用链上的所有对象都是存活对象；不在引用链上的对象为不可达对象，不可达对象就是要回收的垃圾对象 <ul><li>可作为GCRoot的对象元素 <ul><li>虚拟机栈所引用的对象</li><li>本地方法栈所引用的对象</li><li>方法区静态变量引用的对象</li><li>方法区常量引用的对象</li><li>同步锁持有的对象</li><li>虚拟机的内部引用，如常驻的异常对象、class对象、类加载器对象</li><li>虚拟机监控对象、本地代码缓存对象、JVMTI中注册的回调等</li></ul></li><li>临时性加入的对象</li></ul></li><li>我们希望有这样一种情况：如果内存空间足够时，就把对象保留到内存中；如果内存空间不够时，就清理掉对象。 <ul><li>对引用分等级，视内存紧张程度来决定是否回收 <ul><li>强引用，StrongReference <ul><li>只要存在强引用，就不会被回收</li></ul></li><li>软引用，SoftReference <ul><li>下次GC一定会回收软引用的对象</li></ul></li><li>弱引用，WeakReference <ul><li>下次GC前，不管空间是否够用，一律回收</li></ul></li><li>虚引用，PhantomReference <ul><li>虚引用的对象在回收时收到系统的一个通知</li></ul></li><li>终结引用，FinalReference <ul><li>供Finalizer线程找到被引用对象，并调用其finalization()方法，第二次GC时才能回收被引用对象</li></ul></li></ul></li></ul></li></ul></li><li>详细细节 <ul><li>对象的finalization()方法 <ul><li>Java语言提供的一种机制，为了让程序员控制一些类在销毁前做一些自定义操作</li><li>特性 <ul><li>可以被子类重写</li><li>程序员提供销毁前的自定义处理逻辑，实际调用过程则由JVM完成</li><li>垃圾回收器在销毁对象之前，总是会先调用一下对象的finalization()方法</li><li>垃圾收集器调用finalization()方法可能会导致对象“复活”，极端情况下垃圾收集器不会掉用finalization()方法</li></ul></li></ul></li><li>两次标记过程 <ul><li>第一次标记：筛选没有被GCRoot引用的对象 <ul><li>看GCRoot引用链上是否有此对象</li></ul></li><li>第二次标记：触发没有被GCRoot引用的对象的finalization()方法 <ul><li>finalization()方法已经被调用过。如果此对象没有重写finalization()方法且finalization()方法已经被虚拟机调用过了，或者此对象重写了finalization()方法，也已经被虚拟机调用过了，则直接标记这个对象为不可触及对象</li><li>finalization()方法还没有被调用过。链接如果此对象没有被调用过finalization()方法，虚拟机就会创建一个F-queue的队列，并把这个对象放到这个队列里面，之后由一个低优先级的Finalizer线程依次触发队列里面对象的finalization()方法。如果finalization()方法执行完成之后，对象依然没有与引用链上的其他对象建立引用，就标记此对象为不可触及对象，并剔除对列里面与引用链上的某一个对象建立了引用关系的对象</li></ul></li><li>判断一个对象能否被回收 <ul><li><img src="/assets/1677241921712-7aebd7d3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul></li></ul></li><li><p>统计出所有需要回收的对象【Jav./ch07-garbagecollection/image/1677241921712.png</p><ul><li>枚举根节点 <ul><li>迄今为止，所有收集器在枚举根节点这一步骤都是必须暂停用户线程的（jvm中在垃圾回收的时候单独开辟一个线程去收集垃圾的，在收集的过程中，用户线程在不断产生新的垃圾，因此需要暂停用户线程），如果根节点过多，那么收集就会耗费很长时间，也就是暂停时间过长，那么势必会影响整个jvm的吞吐量，因此一定会有一个地方存放着；</li><li>HotSpot的解决方案中，会使用一组称为OopMap的数据结构来达到这个目的，在类加载完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即使编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用</li></ul></li><li>更新记忆集 <ul><li>所有涉及到部分区域收集行为的垃圾收集器，都会<code>面临着非收集区域指向收集区域的跨区域引用的问题</code>；</li><li>额外开辟一块内存区域，然后创建一种数据结构，就记录非收集区域指向收集区域的指针或引用，这种数据结构就叫记忆集；每次垃圾回收时，只需要关注记忆集和根节点就行，免去了每次都要扫描全部区域的麻烦</li><li>简单来说，就是对收集区域进行划分，然后进行编号，之后就会形成一个数组，如果此区域包含了跨代引用或跨区域引用的对象，那么这个位置的值就设置为1，这样每次进行回收的时候，碰到为1的位置就不进行回收了，这样形成的数组就是卡表；</li><li>卡表由很多中具体的实现方式，可以卡对象的精度，也可以卡内存快的精度，还可以卡字长的精度。所谓卡对象的精度，就是对对象进行编号，存在跨代引用就把这个编号的值置为1，卡字长的精度，就是根据jvm的字长进行编号；</li><li>更新记忆集的时候也是会产生并发一致性的问题，即在垃圾回收需要读取记忆集信息的时候，会同时产生新的引用信息；HotSpot是使用写屏障的技术手段来解决这个问题的；</li><li>使用AOP的思想，在对象赋值操作时，对卡表进行更新，即在对象赋值操作时建立切面，然后生成更新卡表的代码语句；</li></ul></li><li>三色标记 <ul><li>收集线程所产生的开销会随着收集区域的扩大而扩大，这会造成jvm吞吐量的下降；</li><li>收集线程在进行第二次标记时，用户线程也在重新建立引用或删除引用，即第二次标记时，对象引用关系发生了改变，采用三色标记方式进行解决； <ul><li>黑色：第一次标记时，被垃圾回收器访问过，且这个对象的所有引用都被扫描过，那么把这个对象标记为黑色；</li><li>灰色：第一次标记时，被垃圾回收器访问过，但是至少有一个引用还没有被扫描到，那么就把这个对象标记为灰色；</li><li>白色：第一次标记时，没有被垃圾回收器访问过，那么就把这个对象标记为白色；</li></ul></li><li>第二次标记完成后，所有的灰色对象要么变成白色、要么变成灰色，之后垃圾回收器只需要回收白色对象，下次垃圾回收会再次忽略黑色对象，直接从白色对象进行第二次标记；</li></ul></li></ul></li></ul><h3 id="_4-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_4-垃圾回收算法" aria-hidden="true">#</a> 4. 垃圾回收算法</h3><h4 id="_4-1-垃圾对象特点" tabindex="-1"><a class="header-anchor" href="#_4-1-垃圾对象特点" aria-hidden="true">#</a> 4.1. 垃圾对象特点</h4><ul><li>绝大多数对象“朝生夕死”</li><li>熬过多次GC后的对象更难消亡</li><li>跨代引用相对于同代引用只占少数比例</li></ul><p>基于上述三条实践原理，把对象分为年轻代、老年代。</p><ul><li>划分 <ul><li>分区 <ul><li>如何划分区域 <ul><li>划分为等大小的小区域，化整为零</li></ul></li><li>如何回收 <ul><li>部分回收</li></ul></li></ul></li><li>分代（如何划分及各区域如何回收（或回收的算法）） <ul><li>新生代</li><li>老年代</li><li>方法区</li></ul></li><li>混合 <ul><li>分区+分代</li></ul></li></ul></li><li>清除垃圾 <ul><li>已有的理论成果——垃圾收集算法 <ul><li>标记整理：  让所有存活的对象向内存空间一端移动，然后清理掉边界以外的内存 <ul><li>原理 <ul><li><ol><li>标记阶段： Collector从引用根节点开始遍历，标记所有被引用的对象</li></ol></li><li><ol start="2"><li>清除阶段： 把可以被回收的对象的地址放置到一个空闲列表中，下次进行分配时，先判断垃圾空间是否够用，如果够用就存放</li></ol></li></ul></li><li>缺点 <ul><li><ol><li>效率不高</li></ol></li><li><ol start="2"><li>清理出来的空闲空间不是连续的，产生内存碎片</li></ol></li><li><ol start="3"><li>需要额外空间来保存被清理的对象的地址</li></ol></li></ul></li><li>使用场景 <ul><li>老年代对象收集过程</li></ul></li><li><img src="/assets/1681523254393-4ea8e9c7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>标记清除 <ul><li>原理 <ul><li><ol><li>标记阶段： Collector从引用根节点开始遍历，标记所有被引用的对象</li></ol></li><li>2./ch07-garbagecollection/image/1681523254393.png</li><li><ol start="3"><li>压缩阶段：把剩余没有被清理的对象压缩到内存的一端</li></ol></li></ul></li><li>优缺点 <ul><li><ol><li>解决了内存碎片问题</li></ol></li><li><ol start="2"><li>但是如果对象被其他对象引用，还需要调整引用的地址</li></ol></li></ul></li><li>使用场景 <ul><li>老年代对象收集过程</li></ul></li><li><img src="/assets/1681523278823-e6f3cd62.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>腾出来的空间再次分配时，可以使用“指针碰撞”的方式进行分配</li></ul></li><li>复制算法 <ul><li>原理 <ul><li>准./ch07-garbagecollection/image/1681523278823.png存空间全部清空即可</li></ul></li><li>优缺点 <ul><li>没有标记和清除阶段，运行效率较高</li><li>不会出现内存碎片问题</li><li>但是需要两倍内存空间</li><li>对于分区域收集的垃圾回收器，需要维护跨区域引用的关系，会产生额外的性能开销</li></ul></li><li>使用场景 <ul><li>适合<strong>垃圾对象较多，存活对象较少</strong>的场景。因此，<strong>是现在大多数商用虚拟机新生代所采用的收集算法</strong></li></ul></li><li><img src="/assets/1681523298158-4a7128db.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>增量收集算法 <ul><li>原理 <ul><li>通过妥善处理“垃圾清理线程”与“用户工作线程”的切换，让垃圾清理线程每次只清理一小块内存区域。</li></ul></li><li>优缺点./ch07-garbagecollection/image/1681523298158.png <ul><li>减少每次垃圾回收的停顿时间</li><li>需要妥善处理好“垃圾清理线程”与“用户工作线程”的切换问题，并且线程切换会带来损耗，造成系统吞吐量下降</li></ul></li></ul></li><li>分区收集算法 <ul><li>原理 <ul><li>把整块内存区域“化整为零”，每个小块空间独立使用，独立回收</li></ul></li><li>优缺点 <ul><li>可以控制每次回收多少个小区间，达到停顿时间可控的目的</li></ul></li></ul></li><li>都会产生STW <ul><li>GC发生过程中，会导致所有用户线程都暂停，像是整个世界都停止了一样</li><li>特性 <ul><li>所有的GC回收器都会产生</li><li>是由JVM主动发起的</li><li>调优的主要目的就是降低STW的停顿时间</li></ul></li><li>原因 <ul><li>收集垃圾时需要在一个一致性快照中进行，不能一边清理垃圾一边产生垃圾</li></ul></li><li>停顿的时间点 <ul><li>安全点 <ul><li>在某一时刻，所有的用户线程都会停下来，让jvm标识垃圾，这个时刻就是安全点。</li><li>所有的用户线程主动轮训一个GC标志位并采用主动中断的方式来挂起自身线程</li></ul></li><li>安全区 <ul><li>如果单单是安全点，那么所有的线程都会在这个点进行主动中断，这就会出现有些线程等待时间过长的问题，因此可以延长这个“时刻”，把“时刻”变成“时间段”，这个时间段就是安全区，在这个安全区内，代码引用关系不会发生改变，换言之在这个区域内任何地方开始GC操作，都是等价的。</li></ul></li></ul></li></ul></li></ul></li><li>最佳实践——分代收集算法 <ul><li>新生代 <ul><li>特点 <ul><li>区域小、对象生命周期短、存活率低、回收频繁</li></ul></li><li>最佳实践 <ul><li>复制算法</li></ul></li></ul></li><li>老年代 <ul><li>特点 <ul><li>区域大、对象生命周期长、存活率高、回收不是很频繁</li></ul></li><li>最佳实践 <ul><li>“标记清除”与“标记整理”混合使用</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="_5-垃圾回收的时机" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收的时机" aria-hidden="true">#</a> 5. 垃圾回收的时机</h3><ul><li>不能一边打扫房间一边丢垃圾，必须在某一时刻停止制造垃圾的用户线程。所以这个 【停止用户工作线程的时刻】 和 【用户工作线程的停止时间间隔】 就比较重要，不可能随时随地停止，也不可能停止无限长的时间。</li><li>用户工作线程停止的时刻 <ul><li>选择标准 <ul><li>是否具有让程序长时间执行的特征</li></ul></li><li>分类 <ul><li>安全点： 虚拟机会选取一些能够长时间执行的指令作为安全点，并在安全点处采用主动中断的方式挂起所有用户线程（主动中断就是用户线程主动去轮询一个GC标志位，如果标志位为真，表示要进行GC回收，此时用户线程就会主动中断）</li><li>安全区域 <ul><li>只有安全点的概念，会使主动中断等待的时间过长（GC线程等待所有用户线程都到达安全点才主动中断），试想在一个区域内才更加合理，这个区间就是安全区域</li></ul></li></ul></li><li>停顿之后主线程的工作方式</li></ul></li><li>用户工作线程停止的方式 <ul><li>主动中断 <ul><li>主动中断就是用户线程主动去轮询一个GC标志位，如果标志位为真，表示要进行GC回收，此时用户线程就会主动中断</li></ul></li><li>被动阻塞</li></ul></li><li>用户工作线程停止的时长 <ul><li>全局停顿时间 <ul><li>在新生代进行的GC叫做minor GC，在老年代进行的GC都叫major GC，Full GC同时作用于新生代和老年代。在垃圾回收过程中经常涉及到对对象的挪动（比如上文提到的对象在Survivor 0和Survivor 1之间的复制），进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿。Stop-The-World对系统性能存在影响，因此垃圾回收的一个原则是尽量减少“Stop-The-World”的时间</li></ul></li></ul></li></ul><h3 id="_6-垃圾回收需要考虑的问题" tabindex="-1"><a class="header-anchor" href="#_6-垃圾回收需要考虑的问题" aria-hidden="true">#</a> 6. 垃圾回收需要考虑的问题</h3><ul><li>要回收垃圾，就要暂停JVM中所有应用程序，理论上回收的区域越大、暂停的时间也就越多，用户线程等待时间也就越长；用户线程等待的时间越长，意味着相同时间内的吞吐量就越小；</li><li>性能指标 <ul><li>吞吐量 <ul><li>系统运行时间占总时间的比例</li></ul></li><li>停顿时间 <ul><li>二者是相互竞争的</li><li>调优的目标**： 在最大吞吐量优先的前提下，尽量缩短停顿时间**</li></ul></li><li>收集频率</li><li>内存占用</li><li>垃圾收集的开销</li><li>服务器性能指标</li><li>JVM性能指标</li><li>应用性能指标</li></ul></li></ul><h3 id="_7-gc类型" tabindex="-1"><a class="header-anchor" href="#_7-gc类型" aria-hidden="true">#</a> 7. GC类型</h3><ul><li>按照【部分回收 or 全部回收】分为 <ul><li>PartitionGC <ul><li>对整个堆空间的部分回收</li></ul></li><li>FullGC <ul><li>对整个堆空间进行整体回收，包括Java堆和方法区</li></ul></li></ul></li><li>按照【针对老年代进行回收 or 针对新生代进行回收】分为 <ul><li>MinorGC（有时也称YoungGC） <ul><li>对Eden区、S0区、S1区进行回收，回收过程会产生STW</li></ul></li><li>MajorGC <ul><li>只对Tenured区（养老区，也称老年代区）进行回收，回收过程也会产生STW，但是是新生代耗时的好几倍</li></ul></li></ul></li><li>事实上，我们对JVM调优，根本目的<strong>在于如何减少MajorGC是造成的STW的时间</strong></li></ul><h5 id="_7-0-1-minor-gc、major-gc、full-gc" tabindex="-1"><a class="header-anchor" href="#_7-0-1-minor-gc、major-gc、full-gc" aria-hidden="true">#</a> 7.0.1. Minor GC、Major GC、Full GC</h5><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。 针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： <ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 <ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 <ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><hr><p>著作权归@pdai所有 原文链接：<a href="https://pdai.tech/md/java/jvm/java-jvm-gc.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/jvm/java-jvm-gc.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_8-垃圾回收器分类" tabindex="-1"><a class="header-anchor" href="#_8-垃圾回收器分类" aria-hidden="true">#</a> 8. 垃圾回收器分类</h3><ul><li>按照线程工作模式 <ul><li>串行垃圾回收器</li><li>并行垃圾回收器</li></ul></li><li>按照碎片处理方式 <ul><li>压缩式垃圾回收器</li><li>非压缩式垃圾回收器</li></ul></li><li>按照工作的内存区间 <ul><li>新生代垃圾回收器</li><li>老年代垃圾回收器</li></ul></li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vongdefu/vongdefu.github.io/edit/main/demo/theme-docs/src/02-java/jvm/ch07-garbagecollection.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="page-nav"><a href="/02-java/jvm/ch06-engine.html" class="nav-link prev" aria-label="6. 执行引擎"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->6. 执行引擎</div></a><a href="/02-java/jvm/ch08-hotspot.html" class="nav-link next" aria-label="8. Hotspot"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">8. Hotspot<!----></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">浪漫骑士的二流键盘</div><div class="copyright">Copyright © 2025 vongdefu</div></footer></div><!--]--><!----><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-fb6938a2.js" defer></script>
  </body>
</html>
