import{_ as l,W as e,X as i,a0 as t}from"./framework-16b96b76.js";const o={},s=t(`<h1 id="_4-内存管理" tabindex="-1"><a class="header-anchor" href="#_4-内存管理" aria-hidden="true">#</a> 4. 内存管理</h1><p>内存管理主要是指两部分内容：</p><ol><li>键的驱逐策略；</li><li>当内存不够用时，内存回收策略；</li></ol><h3 id="_4-1-键的驱逐策略-删除策略" tabindex="-1"><a class="header-anchor" href="#_4-1-键的驱逐策略-删除策略" aria-hidden="true">#</a> 4.1. 键的驱逐策略（删除策略）</h3><h4 id="_4-1-1-redis-中键的过期时间的管理" tabindex="-1"><a class="header-anchor" href="#_4-1-1-redis-中键的过期时间的管理" aria-hidden="true">#</a> 4.1.1. Redis 中键的过期时间的管理</h4><p>Redis提供了四个命令来设置过期时间（生存时间）。</p><ol><li><strong>EXPIRE <code>&lt;key&gt;</code> <code>&lt;ttl&gt;</code></strong> ：表示将键 key 的生存时间设置为 ttl 秒。</li><li><strong>PEXPIRE <code>&lt;key&gt;</code> <code>&lt;ttl&gt;</code></strong> ：表示将键 key 的生存时间设置为 ttl 毫秒。</li><li><strong>EXPIREAT <code>&lt;key&gt;</code> <code>&lt;timestamp&gt;</code></strong> ：表示将键 key 的生存时间设置为 timestamp 所指定的秒数时间戳。</li><li><strong>PEXPIREAT <code>&lt;key&gt;</code> <code>&lt;timestamp&gt;</code></strong> ：表示将键 key 的生存时间设置为 timestamp 所指定的毫秒数时间戳。</li></ol><blockquote><p>PS：在Redis内部实现中，前面三个设置过期时间的命令最后都会转换成最后一个 PEXPIREAT 命令来完成。</p></blockquote><p>移除过期时间：</p><ul><li><strong>PERSIST <code>&lt;key&gt;</code></strong> ：表示将key的过期时间移除。</li></ul><p>返回剩余生存时间：</p><ul><li><strong>TTL <code>&lt;key&gt;</code></strong> ：以秒的单位返回键 key 的剩余生存时间。</li><li><strong>PTTL <code>&lt;key&gt;</code></strong> ：以毫秒的单位返回键 key 的剩余生存时间。</li></ul><h4 id="_4-1-2-删除带过期时间的-key-的通用做法" tabindex="-1"><a class="header-anchor" href="#_4-1-2-删除带过期时间的-key-的通用做法" aria-hidden="true">#</a> 4.1.2. 删除带过期时间的 key 的通用做法</h4><p>软件工程学中，删除带过期时间的 key 的通用做法主要有以下三种：</p><ol><li><strong>定时删除</strong>： 设置过期时间时，创建一个定时器，过期时间一到，操作系统自动触发定时器，立马执行删除方法。 <ul><li>优点：定时删除对内存是最友好的，能够保证内存的key一旦过期就能立即从内存中删除。</li><li>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。并且 key 很多时就需要很多的定时任务来完成，这个也是一个不小的性能开销；</li></ul></li><li><strong>惰性删除</strong>： 用到时，先判断一下是否过期了，没过期就允许操作，过期了就执行删除方法。 <ul><li>特点：这种删除方式有两种实现思路 <ul><li>同步删除： 即哪个线程用到，就由哪个线程来完成删除动作，这个过程是阻塞的；</li><li>异步删除： 即碰到过期情况时，用到这个 key 的线程会通知另外的删除线程，让另外的删除线程来完成删除动作，之后直接返回过期的响应结果；</li></ul></li><li>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</li><li>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</li></ul></li><li><strong>定期删除</strong>： 并不是为每一个key都设置一个定时器，而是设置一个额外的定时器，这个定时器会<strong>定期扫描</strong>部分数据，然后删除过期的。 <ol><li>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</li><li>缺点：难以确定删除操作执行的时长和频率。 <ol><li>如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。</li><li>如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</li><li>另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</li></ol></li></ol></li></ol><h4 id="_4-1-3-redis-中的键的驱逐策略-删除策略" tabindex="-1"><a class="header-anchor" href="#_4-1-3-redis-中的键的驱逐策略-删除策略" aria-hidden="true">#</a> 4.1.3. redis 中的键的驱逐策略（删除策略）</h4><blockquote><p>eviction： 美: [ɪˈvɪkʃən]， 英: [ɪˈvɪkʃ(ə)n]， **n.**赶出；(租地,租房等的)收回；**网络释义：**驱逐；逐出；驱逐租客</p></blockquote><p>Redis 中键的驱逐策略（删除策略）是组合使用的，即使用「<strong>惰性删除+定期删除</strong>」两种策略配合使用的方式。</p><ol><li><p>键的过期的判断过程</p><p>在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个过期字典中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。</p></li><li><p>惰性删除</p><p>惰性删除：Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。</p><p>大多情况下惰性删除都是阻塞式的，也就是说删除过程是由发起命令的线程来执行的，这就会出现另外一个问题，那就是有时候碰到大 key 时，可能会导致主线程秒级的阻塞，这对 redis 服务端的吞吐量是个巨大的影响；因此 redis 提供了另外一种删除方式：非阻塞式惰性删除，也可以称作异步删除，其大概原理是：在主线程的基础上再开启一个新线程来完成删除动作。</p><p>惰性删除是默认开启的，但是有一些业务场景中并不需要惰性删除，而是需要立即删除，例如：</p><ol><li>在为新的 key 分配内存空间时，发现内存空间不足以分配给新 key 了，那就不能够再使用惰性删除了，而是应该立刻删除；</li><li>使用 EXPIRE 命令让一个 key 过期时，也需要立刻删除这个 key；</li><li>再比如 RENAME 命令需要删除旧的键名，这个过程也是要立刻删除旧 key 的；</li><li>再比如，主从复制运行模式下，主节点执行了 flusdb 等清库的命令时，也是需要立刻同步到从库的；</li></ol><p>上面这四种情况下，是不需要惰性删除的，而是需要立即删除的，在配置文件中的<strong>LAZY FREEING</strong>部分，可以对这四种情况进行配置，使它们不使用惰性删除，no 表示不使用惰性删除：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">lazyfree-lazy-eviction</span> <span class="token value attr-value">no     # 表示键驱逐时，不使用惰性删除，而是直接删除；</span>
<span class="token key attr-name">lazyfree-lazy-expire</span> <span class="token value attr-value">no      # 表示使用一些过期命令时，不使用惰性删除；</span>
<span class="token key attr-name">lazyfree-lazy-server-del</span> <span class="token value attr-value">no    # 表示 当server发送一些删除式命令时，不使用惰性删除；【server和客户端是同一角色，它们都可以给存储引擎部分发送命令】</span>
<span class="token key attr-name">replica-lazy-flush</span> <span class="token value attr-value">no       # 表示主从运行模式下不会使用惰性删除；</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>定期删除</p><p>由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p><p>注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。 定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 hz 选项来调整这个次数。</p><p>看上面对这个参数的解释，建议不要将这个值设置超过 100，否则会对CPU造成比较大的压力。</p></li><li><p>键的驱逐策略的问题</p><p>我们看到，通过过期删除策略，对于某些永远使用不到的键，并且多次定期删除也没选定到并删除，那么这些键同样会一直驻留在内存中，又或者在Redis中存入了大量的键，这些操作可能会导致Redis内存不够用，这时候就需要Redis的内存淘汰策略了。</p></li></ol><h3 id="_4-2-内存回收机制" tabindex="-1"><a class="header-anchor" href="#_4-2-内存回收机制" aria-hidden="true">#</a> 4.2. 内存回收机制</h3><p>我们看到，通过过期删除策略，对于某些永远使用不到的键，并且多次定期删除也没选定到并删除，那么这些键同样会一直驻留在内存中，又或者在Redis中存入了大量的键，这些操作可能会导致Redis内存不够用，这时候就需要Redis的内存淘汰策略了。</p><p>这块对应于配置文件redis.conf 中的MEMORY MANAGEMENT部分。</p><ul><li><strong>maxmemory</strong>: <ul><li>描述：设置 Redis 使用的最大内存量。当 Redis 达到这个内存限制时，会触发内存淘汰策略。</li><li>语法：maxmemory <code>&lt;bytes&gt;</code></li><li>示例：maxmemory 256mb</li></ul></li><li><strong>maxmemory-policy</strong>: <ul><li>描述：设置 Redis 达到内存限制后，使用哪种内存淘汰策略。可能的值包括： <ul><li><strong>volatile-lru</strong>：从设置了过期时间的键值对集合中，淘汰 「<strong>最久未使用</strong>」的；</li><li><strong>allkeys-lru</strong>：从所有键值对集合中，淘汰「<strong>最久未使用</strong>」的；</li><li><strong>volatile-lfu</strong>：从设置了过期时间的键值对集合中，淘汰「<strong>最不常用到</strong>」的；</li><li><strong>allkeys-lfu</strong>：从所有键值对集合中，淘汰「<strong>最不常用到</strong>」的；</li><li><strong>volatile-random</strong>：从设置了过期时间的键值对集合中，「<strong>随机</strong>」淘汰；</li><li><strong>allkeys-random</strong>：从所有键值对集合中，「<strong>随机</strong>」淘汰；</li><li><strong>volatile-ttl</strong>：从设置了过期时间的键值对集合中，淘汰「<strong>即将过期</strong>」的；</li><li><strong>noeviction</strong>：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；redis只响应读命令，对需要申请内存的写命令回复error；</li></ul></li><li>语法：maxmemory-policy <code>&lt;policy&gt;</code></li><li>示例：maxmemory-policy allkeys-lru</li></ul></li><li><strong>maxmemory-samples</strong>: <ul><li>描述：设置 LRU 算法和最少频率使用（LFU）算法进行采样时的样本大小。较大的样本大小能提高精确度，但会增加 CPU 开销。</li><li>语法：maxmemory-samples <code>&lt;number&gt;</code></li><li>示例：maxmemory-samples 5</li></ul></li><li><strong>lfu-log-factor</strong>: <ul><li>描述：设置 LFU 算法的对数因子，控制访问频率计数的增加速度。较高的值会使计数增加速度变慢。</li><li>语法：lfu-log-factor <code>&lt;factor&gt;</code></li><li>示例：lfu-log-factor 10</li></ul></li><li><strong>lfu-decay-time</strong>: <ul><li>描述：设置 LFU 算法的衰减时间，以分钟为单位。计数会每隔这个时间减少一半。</li><li>语法：lfu-decay-time <code>&lt;minutes&gt;</code></li><li>示例：lfu-decay-time 1</li></ul></li></ul><blockquote><p>PS：</p><ol><li>volatile： 美: [ˈvɑlət(ə)l]， 英: [ˈvɒlətaɪl]， adj. ，易变的；无定性的；无常性的；可能急剧波动的； 网络释义：挥发性；挥发性的；不稳定的。<strong>这里表示设置了过期时间的 key</strong>。</li><li>其中 allkeys-xxx 表示： 从所有的键值中淘汰数据；而 volatile-xxx 表示： 从设置了过期键的键值中淘汰数据。</li><li>淘汰时要从圈定的 key 的集合中，选择一部分进行淘汰， 这个选择有三种算法： <ol><li><strong>LRU</strong>（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed）： <strong>最近最少使用的、最久没有使用的</strong>；这种算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰。</li><li><strong>LFU</strong>（<strong>L</strong>east <strong>F</strong>requently <strong>U</strong>sed）： <strong>使用频率最小的、最不常使用到的</strong>；这种算法弥补了 LRU 的弊端；</li><li><strong>random</strong>：随机的；</li></ol></li></ol></blockquote>`,24),r=[s];function n(a,d){return e(),i("div",null,r)}const c=l(o,[["render",n],["__file","ch04-memorymanage.html.vue"]]);export{c as default};
