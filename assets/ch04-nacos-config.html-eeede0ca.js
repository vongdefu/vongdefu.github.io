import{_ as o,W as t,X as l,Y as a,Z as n,$ as e,a0 as i,C as p}from"./framework-16b96b76.js";const c="/assets/1699933269664-842fcd87.png",r="/assets/1699933269756-7cfd0d41.png",d="/assets/1699933269970-cba94f7a.png",u="/assets/1699933270080-ec37175d.png",g="/assets/1699933270197-f691cc7f.png",h="/assets/1699933270289-2cb81419.png",k="/assets/1699933270387-0ee1b7f4.png",f="/assets/1699933270479-651678d5.png",m="/assets/1699933270573-9a4a769c.png",v="/assets/1699933270655-a17d2f5d.png",b="/assets/1699933270749-326efcd4.png",_="/assets/1699933270843-67ce39ca.png",x="/assets/1699933270951-88aacf1b.png",y="/assets/1699933271036-c9c2ce74.png",N={},w=i('<h1 id="_4-nacos服务配置" tabindex="-1"><a class="header-anchor" href="#_4-nacos服务配置" aria-hidden="true">#</a> 4. nacos服务配置</h1><ol><li>分布式服务配置的背景知识；</li><li>技术选型；</li><li>Nacos 相关概念</li><li>实战 <ol><li>SpringBoot 获取本地配置的使用方式；</li><li>接入 Nacos 后获取分布式配置的使用方式； <ol><li>基本使用方式；</li><li>共享配置文件获取配置的使用方式；</li><li>映射成 JavaBean 的使用方式；</li><li>实时更新；</li></ol></li></ol></li><li>Nacos 的最佳实践</li><li>高可用</li></ol><h3 id="_1-背景知识" tabindex="-1"><a class="header-anchor" href="#_1-背景知识" aria-hidden="true">#</a> 1. 背景知识</h3><p>在实际的项目中，一般都会使用到一些配置文件，如配置数据库链接、配置log级别和输出方式……，在传统的单体应用中，我们一般会把配置项与项目部署文件放到一起，配置项会随着代码的修改进行部署生效。这样也无可厚非。</p><p>但是随着技术的发展，在微服务架构中，由于微服务架构具有以下特点：</p><ol><li>具有多个不同的环境，如DEV、SIT、UAT、PRD等；</li><li>迭代周期短；</li><li>配置项多而杂；</li><li>……</li></ol><p>总之，就是配置过程频繁而繁琐。此时如果还用传统单体应用管理配置项的方式来管理配置，就显得有些格格不入了。于是我们需要一种新型的管理配置的方式。此时，配置中心应运而生。</p><h3 id="_2-技术选型" tabindex="-1"><a class="header-anchor" href="#_2-技术选型" aria-hidden="true">#</a> 2. 技术选型</h3><p>早期，配置中心的主要功能特性是管理配置，但随着技术的发展和业务的需求，加上程序员极致热情，配置中心有多了一些权限管理、实时更新、版本管理、灰度管理、安全配置等一系列的高级特性。</p>',9),S={href:"https://mp.weixin.qq.com/s/AUHY3nKZqDbAhkfebOPWCg",target:"_blank",rel:"noopener noreferrer"},V=a("h3",{id:"_3-nacos相关概念",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_3-nacos相关概念","aria-hidden":"true"},"#"),n(" 3. Nacos相关概念")],-1),z=a("blockquote",null,[a("p",null,"微信扫码关注“天晴小猪”（ID： it-come-true），回复“springcloud”，获取本章节实战源码。")],-1),B=a("p",null,"关于nacos服务的搭建过程，请参考笔者系列文章的《分布式服务治理之Nacos》章节，这里不再赘述。Nacos有几个重要的概念：",-1),I=a("code",null,"${prefix}-${spring.profiles.active}.${file-extension}",-1),D={href:"http://spring.application.name",target:"_blank",rel:"noopener noreferrer"},q=a("code",null,"${prefix}-${spring.profiles.active}.${file-extension}",-1),C=a("code",null,"properties",-1),j=a("code",null,"yaml",-1),A=a("li",null,[n("命名空间 "),a("ul",null,[a("li",null,"NameSpace ： 命名空间，是一种隔离手段，用来隔离不同环境或不同分组的profile；"),a("li",null,"Group： 命名分组，也是一种隔离手段，可以在命名空间级别上再次进行隔离；"),a("li",null,"区别： 命名空间的隔离粒度较粗，命名分组的隔离粒度较细；")])],-1),J=i('<p>下面我们通过不同的业务场景，来看一下不同方式获取配置项的区别。</p><h3 id="_4-实战" tabindex="-1"><a class="header-anchor" href="#_4-实战" aria-hidden="true">#</a> 4. 实战</h3><h4 id="_4-1-springboot-传统方式获取本地配置项" tabindex="-1"><a class="header-anchor" href="#_4-1-springboot-传统方式获取本地配置项" aria-hidden="true">#</a> 4.1. SpringBoot 传统方式获取本地配置项</h4><p>直接使用 <a href="/Value">@Value </a> 注解获取即可。实现的大概过程是：</p><ol><li>在配置文件中填写配置内容；</li></ol><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>通过 <a href="/Value">@Value </a> 注解获取配置信息；</li></ol><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种方式有一个缺点：<code>每次修改配置项，都需要重启应用；无法满足在项目中实时感知配置项的变化的需求。</code></p><h4 id="_4-2-接入-nacos-后获取分布式配置的使用方式" tabindex="-1"><a class="header-anchor" href="#_4-2-接入-nacos-后获取分布式配置的使用方式" aria-hidden="true">#</a> 4.2. 接入 Nacos 后获取分布式配置的使用方式</h4><h5 id="_4-2-1-应用接入nacos" tabindex="-1"><a class="header-anchor" href="#_4-2-1-应用接入nacos" aria-hidden="true">#</a> 4.2.1. 应用接入nacos</h5><p>应用程序接入第三方组件的过程大概都可以分成以下几个步骤：</p><ol><li>pom文件中引入组件的相关依赖坐标；</li><li>在配置文件中添加配置项，即配置的key-value键值对，或者使用@Component、@Configuration+JavaBean的方式进行配置；</li><li>有些组件还需要在启动类上添加相关的注解来开启功能；</li><li>进行使用</li></ol><p>Nacos的接入也分成三个步骤：</p><ol><li>pom中引入相关依赖</li></ol><p>由于引入了自制的项目的starter工程来统一管理依赖的版本，因此在这个模块中只需要添加 groupId和artifactId即可，不需要添加版本。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>starter<span class="token operator">-</span>alibaba<span class="token operator">-</span>nacos<span class="token operator">-</span>config<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>配置nacos相关信息</li></ol><p>Nacos作为注册中心，完全替代了原有的配置文件，因此需要使用更高级别的配置文件，即 bootstrap 的配置文件，因此nacos的配置内容需要在 bootstrap.yml 文件中完成。</p><figure><img src="`+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>直接使用</li></ol><p>参见下面使用样例。</p><h5 id="_4-2-2-直接使用nacos获取配置项" tabindex="-1"><a class="header-anchor" href="#_4-2-2-直接使用nacos获取配置项" aria-hidden="true">#</a> 4.2.2. 直接使用nacos获取配置项</h5><ol><li>在nacos的控制台添加配置项</li></ol><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>通过@Value标注变量，并获取配置项</li></ol><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_4-2-3-使用nacos共享配置文件方式获取配置项" tabindex="-1"><a class="header-anchor" href="#_4-2-3-使用nacos共享配置文件方式获取配置项" aria-hidden="true">#</a> 4.2.3. 使用nacos共享配置文件方式获取配置项</h5><p>在实际开发过程中，一个项目可能会有多个配置项，如需要配置redis、mysql、mq等，那么我们就可以使用nacos的共享配置文件的方式获取配置项。</p><ol><li>在bootstrap.yml中添加共享配置项的配置</li></ol><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>在nacos控制台添加共享配置项</li></ol><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>通过@Value标注变量，并获取配置项</li></ol><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_4-2-4-共享配置文件映射成javabean" tabindex="-1"><a class="header-anchor" href="#_4-2-4-共享配置文件映射成javabean" aria-hidden="true">#</a> 4.2.4. 共享配置文件映射成JavaBean</h5><p>上面的样例中，我们都是先通过@Value标注变量，但是这种方式还有不够便捷，既然是面向对象编程，那么我们就希望获取到的配置文件转成JavaBean的方式进行使用。请看下面样例：</p><ol><li>在bootstrap.yml中添加共享配置项的配置</li></ol><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>控制台添加配置</li></ol><figure><img src="'+_+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>添加配置项的JavaBean进行映射</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">&quot;mybrother&quot;</span><span class="token punctuation">)</span><span class="token comment">// prefix 的值就是控制台添加的配置文件的名称</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBrotherInfo</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token class-name">String</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSex</span><span class="token punctuation">(</span><span class="token class-name">String</span> sex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>注入JavaBean后进行使用</li></ol><figure><img src="`+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们还可以把不同项目的一些公共配置放到一个配置文件中，然后在不同的项目中设置相同的配置项，达到<code>一处变更，处处修改</code>的目的。</p><h5 id="_4-2-5-实时获取配置变更" tabindex="-1"><a class="header-anchor" href="#_4-2-5-实时获取配置变更" aria-hidden="true">#</a> 4.2.5. 实时获取配置变更</h5><p>获取变更后的配置文件，我们只需要在获取的接口上添加 <a href="/RefreshScope">@RefreshScope </a> 注解即可。</p><h3 id="_5-nacos方式-vs-传统方式" tabindex="-1"><a class="header-anchor" href="#_5-nacos方式-vs-传统方式" aria-hidden="true">#</a> 5. Nacos方式 vs 传统方式</h3><p>传统方式：</p><ol><li>每次配置变更都需要重启服务；</li><li>无法实时感知配置项的变化过程；</li><li>集群架构下，无法实现“一处修改，处处修改”的效果；</li></ol><p>使用nacos作为配置中心：</p><ol><li>配置变更后不需要重启服务；</li><li>可以实时感知到配置的变化过程；</li><li>能实现集群架构下，“一处修改，处处修改”的效果；</li></ol><h3 id="_6-开发的最佳实践" tabindex="-1"><a class="header-anchor" href="#_6-开发的最佳实践" aria-hidden="true">#</a> 6. 开发的最佳实践</h3><blockquote><p>微信扫码关注“天晴小猪”（ID： it-come-true），回复“springcloud”，获取本章节实战源码。</p></blockquote><p>通过上面的案例，我们可以了解到Nacos作为配置中心有几个重要的功能特性：</p><ol><li>命名空间</li><li>命名分组</li><li>共享文件配置</li></ol><p>实际的开发过程肯定要比上面的几种简单案例复杂，那么我们在实际的开发过程中如何使用这几种配置方式呢？</p><h4 id="_6-1-方式一" tabindex="-1"><a class="header-anchor" href="#_6-1-方式一" aria-hidden="true">#</a> 6.1. 方式一</h4><p>为每一个服务都创建一个namespace，然后不同的环境使用不同的Group来隔离。如不同模块的开发环境的配置文件统一放到DEV的命名空间下，在同一个命名空间下，我们可以通过不同的命名分组进行区分，如模块A的开发环境的配置文件属于DEV命名空间下的GroupA，模块B的开发环境的配置文件属于DEV命名空间下的GroupB。</p><p>这样做的好处是符合传统的以不同环境作为区分的思路，便于理解；并且还可以让不同的应用在相同环境下共享配置文件；但是这种方式也有坏处，那就是不能跨环境共享配置文件。</p><h4 id="_6-2-方式二" tabindex="-1"><a class="header-anchor" href="#_6-2-方式二" aria-hidden="true">#</a> 6.2. 方式二</h4><p>为每一个环境都配置一个namespace，不同的服务使用同名的配置文件；实际操作上，我们可以使用服务名作为命名空间，再通过命名分组进行区分不同的环境。这种方式是把不同环境的配置文件放到了同一个命名空间下，实现了不同环境下的共享配置文件的配置。但这种方式也有缺点，那就是可能每一个服务的命名空间中都有相同的一份配置文件，也就是不同服务无法共享一些公共的配置文件。</p><h3 id="_7-nacos的高可用" tabindex="-1"><a class="header-anchor" href="#_7-nacos的高可用" aria-hidden="true">#</a> 7. Nacos的高可用</h3><p>相比较传统单体应用中，配置文件跟业务代码放到一起的方式，配置中心的方式相当于集中管理配置，在使配置便捷化的过程中，也引入了一个重要的问题，那就是：配置中心异常无法对外提供服务后，会导致所有的应用无法获取配置，导致项目启动不起来。</p><p>针对这个问题Nacos也提供了解决方案，那就是Nacos的高可用机制。简单来说就是部署多个Nacos实例，让Nacos形成集群，统一对外提供服务。 Nacos的集群模式这里不再赘述，详见官方文档。</p><p>此外Nacos本身是由Java语言编写，Nacos也支持持久化，有兴趣的读者可以自行研究一下持久化的部署过程。</p><h3 id="_8-总结" tabindex="-1"><a class="header-anchor" href="#_8-总结" aria-hidden="true">#</a> 8. 总结</h3><ol><li>介绍了配置中心出现的背景；</li><li>分别介绍了传统方式获取配置项及Nacos获取配置项的不同方式，并简单介绍了这几种方式的区别；</li><li>介绍了Nacos在实际开发场景下的不同实践方式以及它们的优缺点；</li><li>简单介绍了Nacos的其他高级特性；</li></ol>',72);function E($,G){const s=p("ExternalLinkIcon");return t(),l("div",null,[w,a("p",null,[n("目前，Java领域的配置中心大概有这么几种： Nacos、ZK、Apollo、SpringCloud-Config等。关于不同技术类型的选择方法，参见《"),a("a",S,[n("你真的会做技术选型吗？"),e(s)]),n("》，这里不再赘述，本篇文章，主要介绍一下nacos相关内容。")]),V,z,B,a("ul",null,[a("li",null,[n("Data ID ：配置项的唯一标识，可以理解为一个配置文件，它的命名格式是： "),I,n("， 其中prefix为前缀，默认是 "),a("a",D,[n("spring.application.name"),e(s)]),n(" 的值，当然也可以通过 spring.cloud.nacos.config.prefix 来进行配置；spring.profiles.active为项目生效的profile的名称，这个值和前面的短横杠为空时，DataID变成 "),q,n("，这种方式也是合法的；file-exetension表示配置文件的格式，目前只支持 "),C,n(" 和 "),j,n(" 类型；")]),A]),J])}const R=o(N,[["render",E],["__file","ch04-nacos-config.html.vue"]]);export{R as default};
