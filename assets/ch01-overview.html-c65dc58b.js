import{_ as n,W as o,X as i,Y as a,Z as c,$ as s,a0 as e,C as r}from"./framework-16b96b76.js";const l="/assets/1726239781408-fc807e26.png",p="/assets/1726239782868-fcec98a0.png",d="/assets/1726239784303-78f1da49.png",_={},g=e('<h1 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h1><h3 id="_1-区别" tabindex="-1"><a class="header-anchor" href="#_1-区别" aria-hidden="true">#</a> 1. 区别</h3><figure><img src="'+l+'" alt="1726239781408.png" tabindex="0" loading="lazy"><figcaption>1726239781408.png</figcaption></figure>',3),f={href:"https://docs.oracle.com/javase/specs/index.html",target:"_blank",rel:"noopener noreferrer"},h=e('<p>Java 语言从一开始就是针对跨平台而实现的。为此，它把编程语言的规范与虚拟机的规范分隔开。目的就在于实现虚拟机的跨平台性。比如下面的例子：</p><blockquote><p>Java 语言规范应该包括 Java 源代码的编写规范以及 Javac 编译器的实现规范。</p></blockquote><figure><img src="'+p+'" alt="1726239782868" tabindex="0" loading="lazy"><figcaption>1726239782868</figcaption></figure><figure><img src="'+d+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Java 语言规范与 Java 虚拟机规范可以这样去理解：</p><ol><li>Java 语言规范规定了程序员如何使用 Java 语言写代码，这里的代码特质 Java 源代码；</li><li>而 Java 虚拟机规范则规定了 JVM 如何理解 字节码 文件，并通过调用操作系统相关指令集来完成字节码文件中的相关指令。</li></ol><p>字节码的执行可以看作是： jvm 读取到其中某一条指令后，然后把这条指令转化成操作系统能够理解的底层指令，最后操作硬件完成具体的功能。这里要注意的是：字节码中的指令，全部都是操控 jvm 的，而 jvm 是运行于操作系统之上的，因此 jvm 会把指令转化为操作系统能够理解的底层指令。</p>',7);function m(v,u){const t=r("ExternalLinkIcon");return o(),i("div",null,[g,a("ul",null,[a("li",null,[a("a",f,[c("https://docs.oracle.com/javase/specs/index.html"),s(t)])])]),h])}const J=n(_,[["render",m],["__file","ch01-overview.html.vue"]]);export{J as default};
