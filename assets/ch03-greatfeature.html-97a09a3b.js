import{_ as a,W as e,X as h,a0 as r}from"./framework-16b96b76.js";const d={},i=r('<h1 id="_3-高级特性" tabindex="-1"><a class="header-anchor" href="#_3-高级特性" aria-hidden="true">#</a> 3. 高级特性</h1><h3 id="_3-1-事务" tabindex="-1"><a class="header-anchor" href="#_3-1-事务" aria-hidden="true">#</a> 3.1. 事务</h3><h3 id="_3-2-lua-脚本" tabindex="-1"><a class="header-anchor" href="#_3-2-lua-脚本" aria-hidden="true">#</a> 3.2. LUA 脚本</h3><h3 id="_3-3-消息队列-发布订阅" tabindex="-1"><a class="header-anchor" href="#_3-3-消息队列-发布订阅" aria-hidden="true">#</a> 3.3. 消息队列（发布订阅）</h3><h3 id="_3-4-搜索引擎" tabindex="-1"><a class="header-anchor" href="#_3-4-搜索引擎" aria-hidden="true">#</a> 3.4. 搜索引擎</h3><h3 id="_3-5-管道" tabindex="-1"><a class="header-anchor" href="#_3-5-管道" aria-hidden="true">#</a> 3.5. 管道</h3><p>-Pipeline</p><p>所谓管道技术，就是把之前的一次一个命令的执行方式，变成一次执行多个命令的方式。它本质上是客户端提供的特性，目的是提高客户端的利用效率。</p><p>但在使用时需要注意的是：</p><ol><li>发送的命令数量不会被限制，但是输入缓存区也就是命令的最大存储体积为1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ol><h3 id="_3-6-布隆过滤器" tabindex="-1"><a class="header-anchor" href="#_3-6-布隆过滤器" aria-hidden="true">#</a> 3.6. 布隆过滤器</h3><h3 id="_3-7-迭代器" tabindex="-1"><a class="header-anchor" href="#_3-7-迭代器" aria-hidden="true">#</a> 3.7. 迭代器</h3><h3 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h3>',13),t=[i];function n(c,s){return e(),h("div",null,t)}const l=a(d,[["render",n],["__file","ch03-greatfeature.html.vue"]]);export{l as default};
