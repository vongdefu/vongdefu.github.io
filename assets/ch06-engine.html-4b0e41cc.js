import{_ as a,W as i,X as e,a0 as l}from"./framework-16b96b76.js";const c="/assets/1677230462782-9bf62217.png",n="/assets/1677230478715-2b4c8e81.png",d="/assets/1700724873378-6cad9f5e.png",t={},o=l('<h1 id="_6-执行引擎" tabindex="-1"><a class="header-anchor" href="#_6-执行引擎" aria-hidden="true">#</a> 6. 执行引擎</h1><blockquote><p>AOT</p></blockquote><h3 id="_1-执行方式" tabindex="-1"><a class="header-anchor" href="#_1-执行方式" aria-hidden="true">#</a> 1. 执行方式</h3><ul><li>解释执行 <ul><li>对字节码文件逐行解释执行，换言之，就是依次读取.class文件的每一行，然后把读取到的字节码“翻译”成机器语言进行执行 <ul><li>效率低下</li></ul></li></ul></li><li>编译执行（编译器分类及举例）</li></ul><h3 id="_2-包含内容" tabindex="-1"><a class="header-anchor" href="#_2-包含内容" aria-hidden="true">#</a> 2. 包含内容</h3><ul><li>解释器</li><li>即时编译器 <ul><li>分析器</li></ul></li><li>垃圾回收器</li></ul><h3 id="_3-执行过程" tabindex="-1"><a class="header-anchor" href="#_3-执行过程" aria-hidden="true">#</a> 3. 执行过程</h3><ul><li>Java运行分为两个阶段 <ul><li>第一阶段：把.java文件编译成.class文件 <ul><li><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>第二阶段：运行.class文件 <ul><li><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul><p>./ch06-engine/image/1677230462782.png</p><p>./ch06-engine/image/1677230478715.png</p><hr><h3 id="_4-java中运行代码的方式分为两种-解释运行-和-编译运行。" tabindex="-1"><a class="header-anchor" href="#_4-java中运行代码的方式分为两种-解释运行-和-编译运行。" aria-hidden="true">#</a> 4. Java中运行代码的方式分为两种，<code>解释运行</code> 和 <code>编译运行</code>。</h3><p><code>解释运行</code>是对字节码文件逐行解释执行，换言之，就是依次读取.class文件的每一行，然后把读取到的字节码“翻译”成机器语言进行执行，这种方式效率低下。JS、JSP、ASP等语言都是解释型编程语言。</p><p><code>编译运行</code>则是将一种语言规范转化成另外一种语言规范，即将<code>便于人理解的语言规范</code>转化成<code>机器容易理解的语言规范</code>的过程就是编译。</p><h4 id="_4-1-编译器" tabindex="-1"><a class="header-anchor" href="#_4-1-编译器" aria-hidden="true">#</a> 4.1. 编译器</h4><p>编译运行一般情况下会有专门的编译器来完成编译工作，Java中根据编译器的作用把编译器分为三类：</p><ul><li>前端编译器，主要作用是把.java文件编译成.class文件，如javac、ECJ等；</li><li>后端编译器（JIT即时编译器），主要作用是把字节码文件转变成可执行的机器码，主要有两种C1和C2编译器，C1的启动时间比C2启动时间短，系统稳定后，C2执行效率比C1高；</li><li>静态提前编译器（AOT编译器），直接把.java文件转变成可执行的机器码，包括GCJ等，还处于实验阶段；</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>HotSpotJVM是两种方式并存的。运行过程原理大概是这样的：等待所有的代码编译完成再进行运行是不值得的，项目启动前期就要使用解释器解释执行一些代码，同时也会针对执行到的热点代码进行探测，对热点代码再进行编译执行，相当于对二者进行取长补短。</p><p>使用什么技术探测热点代码？</p><ul><li>使用<code>方法调用计数器</code>统计方法的调用次数，配置参数： -XX:CompileThreshold</li><li>使用<code>回边计数器</code>统计循环体的执行次数</li></ul><p>对热点代码的优化手段？</p><ul><li>栈上分配</li><li>同步消除</li><li>标量替换</li></ul></div><h4 id="_4-2-执行" tabindex="-1"><a class="header-anchor" href="#_4-2-执行" aria-hidden="true">#</a> 4.2. 执行</h4><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果</p><figure><img src="'+d+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>./ch06-engine/image/1700724873378.png</p>',22),s=[o];function r(h,p){return i(),e("div",null,s)}const _=a(t,[["render",r],["__file","ch06-engine.html.vue"]]);export{_ as default};
